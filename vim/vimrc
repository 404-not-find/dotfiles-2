" vim: et sts=2 sw=2
"
"
"   You are about to experience a potent dosage of Vim. Watch your steps.
"
"                ╔══════════════════════════════════════════╗
"                ║           ⎋ HERE BE VIMPIRES ⎋           ║
"                ╚══════════════════════════════════════════╝
"

" plug {{{1
call plug#begin('~/.vim/bundle')
  Plug 'Keithbsmiley/investigate.vim'
  Plug 'Lokaltog/vim-easymotion',        { 'on': '<plug>(easymotion-s2)' }
  Plug 'chrisbra/unicode.vim',           { 'on': ['<plug>(UnicodeComplete)', '<plug>(UnicodeGA)', 'UnicodeTable'] }
  Plug 'fatih/vim-go',                   { 'for': 'go' }
  Plug 'godlygeek/csapprox',             { 'for': 'fugitiveblame' }
  Plug 'junegunn/fzf',                   { 'on': 'FZF', 'dir': '~/local/fzf' }
  Plug 'junegunn/vim-easy-align',        { 'on': '<plug>(LiveEasyAlign)' }
  Plug 'junegunn/vim-github-dashboard',  { 'on': ['GHDashboard', 'GHActivity'] }
  Plug 'junegunn/vim-peekaboo'
  Plug 'lambdatoast/elm.vim',
  Plug 'lervag/vimtex',                  { 'for': 'tex' }
  Plug 'majutsushi/tagbar',              { 'on': 'TagbarToggle' }
  Plug 'mbbill/undotree',                { 'on': 'UndotreeToggle' }
  Plug 'noahfrederick/vim-hemisu'
  Plug 'scrooloose/nerdtree',            { 'on': 'NERDTreeToggle' }
  Plug 'tpope/vim-commentary'
  Plug 'tpope/vim-fugitive'
  Plug 'tpope/vim-rsi'
  Plug 'tpope/vim-surround'
  Plug 'wting/rust.vim',                 { 'for': 'rust'  }

  " Plug '/data/github/nvim-builder'
  Plug '/data/github/nvim-erlang_rocks', { 'for': 'erlang' }
  Plug '/data/github/vim-grepper',       { 'on': 'Grepper' }
  Plug '/data/github/vim-janah'
  " Plug '/data/github/vim-profiling'
  Plug '/data/github/vim-randomtag',     { 'on': 'Random' }
  Plug '/data/github/vim-sayonara',      { 'on': 'Sayonara' }
  Plug '/data/github/vim-signify'
  Plug '/data/github/vim-startify'
call plug#end()

" init {{{1
filetype plugin indent on
syntax   on

"autocmd BufReadPre *.asm let b:asmsyntax = 'nasm'
"let b:asmsyntax = 'armasm'

let s:mac = has('mac')

" set {{{1
" indent settings
set autoindent
set cinoptions    =>4,l1,p0,)50,*50,t0
set expandtab
set shiftwidth    =4
set softtabstop   =4

" backup/swap/info/undo settings
set backup
set backupdir     =$HOME/.vim/files/backup/
set backupext     =-vimbackup
set backupskip    =
set directory     =$HOME/.vim/files/swap//
set undodir       =$HOME/.vim/files/undo/
set undofile
set updatecount   =100
set viminfo       ='100,n$HOME/.vim/files/info/viminfo

" better navigation
set cursorline
set foldmethod    =marker
set foldtext      =Foldy()
set hlsearch
set ignorecase
set incsearch
set mouse         =a
set scrolloff     =4
set sidescroll    =5
set smartcase

" misc settings
set autoread
set backspace     =indent,eol,start
set clipboard     =unnamed
set complete     -=i
set cpoptions    -=e
set diffopt       =filler,vertical,foldcolumn:0
set fileformats   =unix,dos,mac
set hidden
set history       =10000
set lazyredraw
set more
set mousemodel    =popup
set noautowrite
set noautowriteall
set noequalalways
set noerrorbells
set nofsync
set nojoinspaces
set nrformats     =hex
set pastetoggle   =<F5>
set relativenumber
set report        =0
" set sessionoptions-=options
set shiftround
set showfulltag
set showtabline   =1
set smarttab
set splitbelow
set splitright
set switchbuf     =useopen,usetab
set synmaxcol     =200
set timeout
set timeoutlen    =1000
set titlestring   =VIM:\ %f
set ttimeout
set ttimeoutlen   =10
set ttyfast
set virtualedit   =onemore,block
set whichwrap     =h,l

" wild stuff
set suffixes     +=.a,.1,.class
set wildignore   +=*.o,*.so,*.zip,*.png
set wildmenu
set wildmode      =list,full
set wildoptions   =tagfile

" display settings
set display       =lastline
set laststatus    =2
set list
set modeline
set modelines     =1
set nostartofline
set numberwidth   =1
set ruler
set shortmess     =aoOTI
set showcmd
set showmatch
set showmode

" spelling
set spellfile     =~/.vim/spell/en.utf-8.add,~/.vim/spell/de.utf-8.add
set spelllang     =en,de

" breaking
set wrap
set linebreak
set breakindent
set breakindentopt=min:40
"set highlight    +=@:SpecialKey

set cpoptions     =aABcefFqsZ
set formatoptions =tcrqnj

if has('multi_byte') && &encoding ==# 'utf-8'
  let &listchars = 'tab:▸ ,extends:❯,precedes:❮,nbsp:±'
  let &fillchars = 'diff:▚'
  let &showbreak = '↪ '
  highlight VertSplit ctermfg=242
  augroup mylist
    autocmd!
    autocmd InsertEnter * set listchars-=trail:⣿
    autocmd InsertLeave * set listchars+=trail:⣿
  augroup END
else
  let &listchars = 'tab:> ,extends:>,precedes:<,nbsp:.'
  let &fillchars = 'stlnc:#'
  let &showbreak = '-> '
  augroup mylist
    autocmd!
    autocmd InsertEnter * set listchars-=trail:.
    autocmd InsertLeave * set listchars+=trail:.
  augroup END
endif

if executable('ag')
  let &grepprg = 'command ag --nogroup --nocolor'
endif

" mapping {{{1
digraph ./ 8230

let mapleader = ';'

nnoremap \            ;
nmap     ga           <plug>(UnicodeGA)
nnoremap gl           <c-^>

imap     <c-x><c-z>   <plug>(UnicodeComplete)

nnoremap <f1>         :NERDTreeToggle<cr>
nnoremap <f2>         :TagbarToggle<cr>
nnoremap <f3>         :UndotreeToggle<cr>
nnoremap <f4>         :GHDashboard! mhinz<cr>
nnoremap <f5>         :GHActivity! mhinz<cr>
nnoremap <f8>         :Make<cr>
nnoremap <f9>         :Dispatch<cr>
nnoremap <f10>        :Start<cr>
nnoremap <f11>        :let g:stl_group_info = !get(g:, 'stl_group_info')<cr>
nnoremap <f12>        :set spell!<cr>

nnoremap L            :put =''<cr>
nnoremap K            :grep! "\b<c-r><c-w>\b"<cr>:cwindow<cr>

nnoremap <c-g>        :FileInfo<cr>
nnoremap <c-p>        :FZF<cr>

inoremap <c-u>        <c-g>u<c-u>
inoremap jf           <esc>
inoremap <expr> <tab> <sid>tab_yeah("\<c-n>", "\<tab>")
inoremap <silent> <c-g><c-t> <c-r>=repeat(complete(col('.'),map(["%Y-%m-%d %H:%M:%S","%a, %d %b %Y %H:%M:%S %z","%Y %b %d","%d-%b-%y","%a %b %d %T %Z %Y"],'strftime(v:val)')+[localtime()]),0)<cr>
inoremap <silent> <c-g><c-m> <c-r>=repeat(complete(col('.'),['mh.codebro@gmail.com','hinz@campus.tu-berlin.de','mhinz@mailbox.tu-berlin.de']),0)<cr>

nnoremap <leader>ev   :tabnew $MYVIMRC<cr>
nnoremap <leader>rv   :source $MYVIMRC<cr>
nnoremap <leader>rr   :source %<cr>

nnoremap <expr> n     v:searchforward ? 'nzvzz' : 'Nzvzz'
nnoremap <expr> N     v:searchforward ? 'Nzvzz' : 'nzvzz'

nnoremap gg           ggzv
nnoremap G            Gzv

nnoremap [q           :cprevious<cr>
nnoremap ]q           :cnext<cr>
nnoremap [Q           :cfirst<cr>
nnoremap ]Q           :clast<cr>

nnoremap [l           :lprevious<cr>
nnoremap ]l           :lnext<cr>
nnoremap [L           :lfirst<cr>
nnoremap ]L           :llast<cr>

nnoremap [b           :bprevious<cr>
nnoremap ]b           :bnext<cr>
nnoremap [B           :bfirst<cr>
nnoremap ]B           :blast<cr>

nnoremap [t           :tabprevious<cr>
nnoremap ]t           :tabnext<cr>
nnoremap [T           :tabfirst<cr>
nnoremap ]T           :tablast<cr>

nnoremap <c-h>        <c-w>h
nnoremap <c-j>        <c-w>j
nnoremap <c-k>        <c-w>k
nnoremap <c-l>        <c-w>l

onoremap gv           :<c-u>normal! gv<cr>

xnoremap <            <gv
xnoremap >            >gv

nnoremap }            }zz
nnoremap {            {zz
nnoremap ]]           ]]zz
nnoremap [[           [[zz
nnoremap []           []zz
nnoremap ][           ][zz

nnoremap g;           g;zvzz
nnoremap g,           g,zvzz

nnoremap Q            gqap

nnoremap <leader>M    :<c-u><c-r>='let @'. v:register .' = '. string(getreg(v:register))<cr><c-f><left>
nnoremap <leader>j    <C-^>
nnoremap <leader>v    `[v`]

nnoremap <leader>f    :FZF<cr>
nnoremap <leader>g    :Grep<cr>
nnoremap <silent><leader>q    :Sayonara<cr>
nnoremap <silent><leader>Q    :Sayonara!<cr>
nnoremap <leader>w    :update<cr>
nnoremap <leader>x    :xit<cr>

nnoremap <leader>l    :noh<cr>:diffupdate<cr>:syntax sync fromstart<cr><c-l>

nnoremap '            `
nnoremap `            '

nnoremap <bs>         <c-t>
nmap     <expr> <cr>  (&ft == 'vim' && &bt == 'nofile') \|\| &bt == 'quickfix'
      \ ? '<cr>'
      \ : exists('g:cscoped') ? '<leader>cg' : 'g<c-]>'

cnoremap <c-n>        <down>
cnoremap <c-p>        <up>

cnoremap <leader>r    $VIMRUNTIME/
cnoremap <leader>ft   ~/.vim/after/ftplugin/

xnoremap *            :<c-u>call <sid>search()<cr>//<cr>
xnoremap #            :<c-u>call <sid>search()<cr>??<cr>
xnoremap <leader>*    :<c-u>silent! execute <sid>search_all()<cr>

if has('nvim')
  tnoremap <esc> <c-\><c-n>
  tnoremap <a-h> <c-\><c-n><c-w>h
  tnoremap <a-j> <c-\><c-n><c-w>j
  tnoremap <a-k> <c-\><c-n><c-w>k
  tnoremap <a-l> <c-\><c-n><c-w>l
  nnoremap <a-h> <c-w>h
  nnoremap <a-j> <c-w>j
  nnoremap <a-k> <c-w>k
  nnoremap <a-l> <c-w>l
endif

  " let &t_SI = "\<Esc>[4 q"
if !empty($TMUX)
  nnoremap <c-a>      <nop>
  nnoremap <leader>a  <c-a>
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

" autocmd {{{1
augroup myvimrc
  au!

  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe 'normal! g`"zvzz' | endif

  au BufEnter           *                           Cd
  au BufEnter           *.txt                       if &bt == 'help' | call s:helpme() | endif
  au BufLeave           *.h                         mark H
  au BufLeave           *.{c,cpp}                   mark C
  au BufRead,BufNewFile *.[sS]                      let b:asmsyntax = 'gas'
  au BufRead,BufNewFile *.adoc                      setfiletype asciidoc
  au BufRead,BufNewFile *.{md,mkd}                  setlocal ft=markdown tw=80
  au BufRead,BufNewFile /data/repo/neovim/*         setlocal et sts=2 sw=2 cino=>2,l1,p0,)50,*50,t0
  au BufRead,BufNewFile /data/repo/vim/*            setlocal noet
  au BufRead,BufNewFile /data/repo/vim/src/*.[ch]   setlocal sw=4 sts=4
  au BufRead,BufNewFile /data/uni/techgi2/*.{s,asm} setlocal ft=mips
  au BufRead,BufNewFile Makefile.*,local.mk         setfiletype make | setl noet
  au BufReadPost        fugitive://                 setlocal bufhidden=delete
  au BufWritePost       ~/.Xdefaults                redraw | echo system('xrdb ' . expand('<amatch>'))
  au VimEnter           *                           if isdirectory(expand('<afile>')) | Ex | endif

  au User fugitive
        \ if fugitive#buffer().type() =~# '^\%(tree\|blob\)$' |
        \   nnoremap <buffer> .. :edit %:h<cr> |
        \ endif

  au BufReadPost  * if &bin | silent! exe '%!xxd'    | setlocal filetype=xxd | endif
  au BufWritePre  * if &bin | silent! exe '%!xxd -r' | endif
  au BufWritePost * if &bin | silent! exe '%!xxd'    | setlocal nomodified | endif
augroup END

" commands {{{1
command! -bar -nargs=* -complete=help    H           helpgrep <args>
command! -bar -nargs=+ -complete=file    Ag          silent! grep! <args> | cwindow | redraw!
command! -bar -bang    -complete=dir     Cd          call s:cd(<bang>0)
command! -bar                            Scriptnames call <sid>scratch('scriptnames') | sil keepp g/^$/d
command! -bar -nargs=1 -complete=command Scratch     call <sid>scratch(<f-args>)
command! -bar                            CleanSpell  runtime! spell/cleanadd.vim
command! -bar                            FileInfo    echo printf("%s%s [%d,%d/%d] --%d%%--",
      \ expand('%:p'),
      \ &modified ? '[+]' : '',
      \ col('.'),
      \ line('.'),
      \ line('$'),
      \ float2nr(line('.') / (line('$') / 100.0))
      \ )

" functions {{{1
function! s:helpme() abort
  if winnr('$') == 2
    wincmd L
  else
    wincmd T
  endif
endfunction

function! s:cd(bang) abort
  if &buftype =~# '\v(nofile|terminal)' || expand('%') =~# '^fugitive'
    return
  endif
  if !exists('s:cache')
    let s:cache = {}
  endif
  let dirs   = [ '.git', '.hg', '.svn' ]
  let curdir = resolve(expand('%:p:h'))
  if !isdirectory(curdir)
    echohl WarningMsg | echo 'No such directory: '. curdir | echohl NONE
    return
  endif
  if has_key(s:cache, curdir)
    execute (a:bang ? 'cd' : 'lcd') s:cache[curdir]
    return
  endif
  for dir in dirs
    let founddir = finddir(dir, curdir .';')
    if !empty(founddir)
      break
    endif
  endfor
  let dir = empty(founddir) ? curdir : resolve(fnamemodify(founddir, ':p:h:h'))
  let s:cache[curdir] = dir
  execute (a:bang ? 'cd' : 'lcd') fnameescape(dir)
endfunction

function! s:scratch(cmd) abort
  let more = &more
  set nomore
  try
    let lines = 1
    redir => lines
    silent execute a:cmd
  finally
    redir END
    let &more = more
  endtry
  noautocmd new
  setlocal buftype=nofile bufhidden=hide noswapfile
  silent put =lines
  1
  nnoremap <buffer> q :q<cr>
endfunction

function! s:tab_yeah(new, default)
  let line = getline('.')
  let col = col('.') - 2
  if !empty(line) && line[col] =~ '\k' && line[col + 1] !~ '\k'
    return a:new
  else
    return a:default
  endif
endfunction

function! Foldy()
  let linelen = &tw ? &tw : 80
  let marker  = strpart(&fmr, 0, stridx(&fmr, ',')) . '\d*'
  let range   = foldclosedend(v:foldstart) - foldclosed(v:foldstart) + 1

  let left    = substitute(getline(v:foldstart), marker, '', '')
  let leftlen = len(left)

  let right    = range . ' [' . v:foldlevel . ']'
  let rightlen = len(right)

  let tmp    = strpart(left, 0, linelen - rightlen)
  let tmplen = len(tmp)

  if leftlen > len(tmp)
    let left    = strpart(tmp, 0, tmplen - 4) . '... '
    let leftlen = tmplen
  endif

  let fill = repeat(' ', linelen - (leftlen + rightlen))

  return left . fill . right . repeat(' ', 100)
endfunction

function! s:search() abort
  let regsave = @@
  normal! gvy
  let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
  let @@ = regsave
endfunction

function! s:search_all() abort
  call <sid>search()
  call setqflist([])
  execute 'bufdo vimgrepadd! /'. @/ .'/ %'
endfunction

" colors {{{1
if has('gui_running')
  set background=light
  for scheme in ['gruvbox']
    try
      execute 'colorscheme' scheme
      break
    catch
    endtry
  endfor
  set gcr        =a:blinkoff0
  set mousehide
  set guioptions =a
  " let &guifont   = 'Bitstream Vera Sans Mono 9'
  " let &guifont   = 'DejaVu Sans Mono 9'
  " let &guifont   = 'Droid Sans Mono 9'
  let &guifont   = 'Ubuntu Mono 11'
  command! Bigger  :let &guifont = substitute(&guifont, '\d\+$', '\=submatch(0)+1', '')
  command! Smaller :let &guifont = substitute(&guifont, '\d\+$', '\=submatch(0)-1', '')
else
  set background=dark
  augroup mycolors
    autocmd!
    autocmd ColorScheme janah
          \ highlight User1 ctermfg=192 ctermbg=237 cterm=NONE |
          \ highlight User2 ctermfg=167 ctermbg=237 cterm=NONE |
          \ highlight User3 ctermfg=245 ctermbg=237 cterm=NONE |
          \ highlight User4 ctermfg=215 ctermbg=237 cterm=NONE
  augroup END
  for scheme in ['janah', 'gruvbox', 'hemisu', 'desert']
    try
      execute 'colorscheme' scheme
      break
    catch
    endtry
  endfor
endif

" statusline {{{1
function! SetStatusline()
  let stl = ' %4*%<%F%*'

  if exists('b:git_dir')
    let stl    .= '%3*:%*'
    let branch  = fugitive#head(8)
    let stl    .= (branch == 'master') ? '%1*master%*' : '%2*'. branch .'%*'
  endif

  let stl .=
        \   '%m%r%h%w'
        \ . '%= '
        \ . '%#ErrorMsg#%{&paste ? " paste " : ""}%*'
        \ . '%#WarningMsg#%{&ff != "unix" ? " ".&ff." ":""}%* '
        \ . '%#warningmsg#%{&fenc != "utf-8" && &fenc != "" ? " ".&fenc." " :""}%* '

  if get(g:, 'stl_group_info')
      let stl .=
            \   '%#WarningMsg#['
            \ . '%{synIDattr(synIDtrans(synID(line("."),col("."),1)),"name")} '
            \ . '%{synIDattr(synID(line("."),col("."),1),"name")}'
            \ . ']%* '
  endif

  " let stl .=
  "       \   '%Y '
  "       \ . '%3*[%*%v%3*,%*%l%3*/%*%L%3*]%* '
  "       \ . '%p%3*%%%* '

  return stl
endfunction

set statusline=%!SetStatusline()

" plugins {{{1
" plugins: misc {{{2
let g:is_bash      = 1
let g:lisp_rainbow = 1

let g:loaded_2html_plugin     = 1
let g:loaded_getscriptPlugin  = 1
"let g:loaded_gzip             = 1
let g:loaded_rrhelper         = 1
let g:loaded_spellfile_plugin = 1
"let g:loaded_tarPlugin        = 1
let g:loaded_vimballPlugin    = 1
"let g:loaded_zipPlugin        = 1

" plugins: netrw {{{2
" let g:loaded_netrwPlugin = 1
let g:netrw_banner       = 0
let g:netrw_keepdir      = 0
let g:netrw_liststyle    = 1
let g:netrw_sort_options = 'i'

" plugins: surround {{{2
let g:surround_indent = 1
let g:surround_{char2nr('e')} = "\\emph{\r}"
let g:surround_{char2nr('-')} = "<% \r %>"
let g:surround_{char2nr('8')} = "/* \r */"
let g:surround_{char2nr('s')} = " \r"
let g:surround_{char2nr('^')} = "/^\r$/"
let g:surround_{char2nr('=')} = "== \r =="

" plugins: syntastic {{{2
let g:syntastic_enable_signs        = 1
let g:syntastic_check_on_open       = 0
let g:syntastic_enable_highlighting = 1
let g:syntastic_auto_jump           = 0
let g:syntastic_quiet_messages      = { 'level': 'warnings' }
let g:syntastic_mode_map            = {
      \ 'mode'             : 'passive',
      \ 'active_filetypes' : [ 'c' ],
      \ 'passive_filetypes': []
      \ }

let g:syntastic_c_compiler_options   = '-std=c11 -pedantic -Wall -Wextra -Wfloat-equal -ftrapv'
let g:syntastic_cpp_compiler_options = '-std=c++11 -pedantic -Wall -Wextra -Weffc++'

" plugins: tagbar {{{2
let g:tagbar_width     = 40
let g:tagbar_autoclose = 0
let g:tagbar_autofocus = 1
let g:tagbar_compact   = 1

" plugins: vim-easy-align {{{2
vmap <cr>      <plug>(LiveEasyAlign)
nmap <leader>a <plug>(LiveEasyAlign)

" plugins: vim-easymotion {{{2
let g:EasyMotion_do_mapping        = 0
let g:EasyMotion_do_shade          = 1
let g:EasyMotion_inc_highlight     = 0
let g:EasyMotion_landing_highlight = 0
let g:EasyMotion_off_screen_search = 0
let g:EasyMotion_smartcase         = 0
let g:EasyMotion_startofline       = 0
let g:EasyMotion_use_smartsign_us  = 1
let g:EasyMotion_use_upper         = 0

map <space>   <plug>(easymotion-s2)
" map <Leader>j <plug>(easymotion-j)
" map <Leader>k <plug>(easymotion-k)

" plugins: vim-grepper {{{2
let g:grepper = {
      \ 'use_quickfix': 1,
      \ 'do_open': 1,
      \ 'order': ['grep', 'ack', 'ag'],
      \ }
 
" autocmd User Grepper execute g:grepper.use_quickfix ? 'copen' : 'lopen'

" plugins: vim-signify {{{2
let g:signify_vcs_list           = [ 'git', 'hg' ]
"let g:signify_skip_filetype      = { 'help': 1 }
"let g:signify_cursorhold_insert  = 1
"let g:signify_cursorhold_normal  = 1
" let g:signify_disable_by_default = 1
" let g:signify_line_highlight     = 0
"let g:signify_update_on_bufenter = 1
" let g:signify_update_on_focusgained = 0

" function! RunOnModifiedLines(lnums) abort
"   for lnum in a:lnums
"     execute 'silent! '. lnum .'substitute/\s\+$//'
"   endfor
" endfunction

"let g:signify_action_on_modified_lines = 'RunOnModifiedLines'

omap ic <plug>(signify-motion-inner-pending)
xmap ic <plug>(signify-motion-inner-visual)
omap ac <plug>(signify-motion-outer-pending)
xmap ac <plug>(signify-motion-outer-visual)

" plugins: vim-startify {{{2
let g:startify_list_order = [
      \ ['   MRU:'],
      \ 'files' ,
      \ ['   MRU (dir):'],
      \ 'dir',
      \ ['   Sessions:'],
      \ 'sessions',
      \ ['   Bookmarks:'],
      \ 'bookmarks',
      \ ]
" autocmd User Startified nmap <buffer> o <plug>(startify-open-buffers)
" autocmd User Startified
"       \ execute 'nunmap <buffer> i' |
"       \ setlocal modifiable |
"       \ autocmd InsertEnter <buffer> enew

let g:startify_relative_path          = 0
let g:startify_files_number           = 8
let g:startify_session_persistence    = 0
let g:startify_session_autoload       = 1
let g:startify_session_delete_buffers = 1
let g:startify_change_to_dir          = 0
let g:startify_enable_special         = 0
let g:startify_enable_unsafe          = 0

" let g:startify_session_remove_lines   = ['winheight', 'winwidth']
" let g:startify_custom_indices         = ['f', 'g', 'h']
" let g:startify_custom_indices         = map(range(1,100), 'string(v:val)')

let g:startify_skiplist = [
      \ 'COMMIT_EDITMSG',
      \ '\.fugitiveblame',
      \ $VIMRUNTIME .'/doc',
      \ 'bundle/.*/doc',
      \ '\.vimgolf',
      \ ]

function! s:center_header(lines) abort
  let longest_line   = max(map(copy(a:lines), 'len(v:val)'))
  let centered_lines = map(copy(a:lines), 'repeat(" ", (&columns / 2) - (longest_line / 2)) . v:val')
  return centered_lines
endfunction

let g:startify_custom_header = s:center_header(split(system('tips | '. (s:mac ? 'cowthink' : 'cowsay -f apt')), '\n'))
" let g:startify_custom_footer = ['', "   Vim is charityware. Please read ':help uganda'.", '']

"function! s:foo()
    "redir => var
      "silent! echomsg 'foo'
      "silent! echomsg 'bar'
      "silent! echomsg 'quux'
    "redir END
    "return map(split(var, '\n'), '"   " . v:val') + ['']
"endfunction
"let g:startify_custom_header = s:foo()

" let g:startify_session_savevars = ['g:foo']
" let g:startify_session_savecmds = [ 'colo molokai' ]
