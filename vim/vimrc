" vim: et sts=2 sw=2
"
"
"   You are about to experience a potent dosage of Vim. Watch your steps.
"
"                ╔══════════════════════════════════════════╗
"                ║           ⎋ HERE BE VIMPIRES ⎋           ║
"                ╚══════════════════════════════════════════╝
"

" plug {{{1
call plug#begin('~/.vim/bundle')
  " Plug 'terryma/vim-multiple-cursors'
  " Plug 'scrooloose/syntastic'
  " Plug 'scrooloose/nerdtree',    { 'on': ['NERDTree', 'NERDTreeToggle'] }
  " Plug 'majutsushi/tagbar',      { 'on': 'TagbarToggle'                 }

  Plug 'Lokaltog/vim-easymotion'
  Plug 'jamessan/vim-gnupg'
  Plug 'msanders/snipmate.vim',  { 'frozen': 1 }
  Plug 'tpope/vim-commentary'
  Plug 'tpope/vim-dispatch'
  Plug 'tpope/vim-fugitive'
  Plug 'tpope/vim-rsi'
  Plug 'tpope/vim-surround'
  Plug 'wincent/command-t'

  Plug '/data/github/vim-janah'
  Plug '/data/github/vim-perf'
  Plug '/data/github/vim-randomtag', { 'on': 'Random' }
  Plug '/data/github/vim-signify'
  Plug '/data/github/vim-startify'
  Plug '/data/github/vim-tmuxify'
call plug#end()

" init {{{1
filetype plugin indent on
syntax   on

"autocmd BufReadPre *.asm let b:asmsyntax = 'nasm'
"let b:asmsyntax = 'armasm'
let b:debug_highlight = 0

" colors {{{1
if has('gui_running')
  set background=light
  for scheme in ['zenburn', 'pyte', 'solarized']
    try
      execute 'colorscheme' scheme
      break
    catch
    endtry
  endfor
  set gcr        =a:blinkoff0
  set mousehide
  set guioptions =a
  let &guifont   = 'DejaVu Sans Mono 9'
else
  set background=dark
  for scheme in ['janah', 'zenburn', 'xoria256', 'tango2']
    try
      execute 'colorscheme' scheme
      break
    catch
    endtry
  endfor
  if colors_name == 'janah'
    highlight Normal ctermbg=NONE
  endif
endif

" set {{{1
" indent settings
set autoindent
set cinoptions    =>4,l1,p0,)50,*50,t0
set expandtab
set shiftwidth    =4
set softtabstop   =4

" backup/swap/info/undo settings
set backup
set backupdir     =$HOME/.vim/files/backup/
set backupext     =-vimbackup
set backupskip    =
set directory     =$HOME/.vim/files/swap//
set undodir       =$HOME/.vim/files/undo/
set undofile
set updatecount   =100
set viminfo       ='100,n$HOME/.vim/files/info/viminfo

" better navigation
set cursorline
set foldmethod    =marker
set foldtext      =Foldy()
set hlsearch
set ignorecase
set incsearch
set mouse         =a
set scrolloff     =4
set sidescroll    =5
set smartcase

" misc settings
set autoread
set backspace     =indent,eol,start
set cpoptions    -=e
set cscopetag
set cscopetagorder=0
set diffopt       =filler,foldcolumn:0
set fileformats   =unix,dos,mac
set hidden
set history       =10000
set lazyredraw
set more
set mousemodel    =popup
set noautoread
set noautowrite
set noautowriteall
set noequalalways
set noerrorbells
set nofsync
set nojoinspaces
set nrformats     =hex
set pastetoggle   =<F5>
set report        =0
set shiftround
set showfulltag
set showtabline   =1
set smarttab
set splitbelow
set splitright
set switchbuf     =useopen,usetab
set synmaxcol     =200
set timeout
set timeoutlen    =1000
set titlestring   =VIM:\ %f
set ttimeout
set ttimeoutlen   =10
set ttyfast
set virtualedit   =onemore,block
set whichwrap     =

" wild stuff
set suffixes     +=.a,.1,.class
set wildignore   +=*.o,*.so,*.zip,*.png
set wildmenu
set wildmode      =list,full

" display settings
set laststatus    =2
set list
set modeline
set modelines     =1
set nostartofline
set numberwidth   =1
set ruler
set shortmess     =aoOTI
set showcmd
set showmatch
set showmode

" breaking
set wrap
set linebreak
set breakindent
set breakindentopt=min:40
"set highlight    +=@:SpecialKey
"set cpoptions    +=n

if has('multi_byte') && &encoding ==# 'utf-8'
  let &listchars = 'tab:▸ ,extends:❯,precedes:❮,nbsp:±'
  let &fillchars = 'vert:▚,diff:⣿,stlnc:!'
  let &showbreak = '↪ '
  highlight VertSplit ctermfg=242
  autocmd InsertEnter * set listchars-=trail:·
  autocmd InsertLeave * set listchars+=trail:·
else
  let &listchars = 'tab:> ,extends:>,precedes:<,nbsp:.'
  let &fillchars = 'stlnc:#'
  let &showbreak = '-> '
  autocmd InsertEnter * set listchars-=trail:.
  autocmd InsertLeave * set listchars+=trail:.
endif

if executable('ag')
  let &grepprg = 'command ag --nogroup --nocolor'
endif

" mapping {{{1
digraph ./ 8230

let mapleader = ';'

nnoremap K           :grep! "\b<c-r><c-w>\b"<cr>:cwindow<cr>

nnoremap <leader>ev  :tabnew ~/.vim/vimrc<cr>
nnoremap <leader>rr  :source %<cr>
nnoremap <leader>rv  :source $MYVIMRC<cr>

nnoremap <expr> n    v:searchforward ? 'nzvzz' : 'Nzvzz'
nnoremap <expr> N    v:searchforward ? 'Nzvzz' : 'nzvzz'

nnoremap <leader>f   zazz
nnoremap gg          ggzv
nnoremap G           Gzv

nnoremap ]q          :cnext<cr>
nnoremap [q          :cprevious<cr>
nnoremap ]l          :lnext<cr>
nnoremap [l          :lprevious<cr>

nnoremap ]b          :bnext<cr>
nnoremap [b          :bprevious<cr>
nnoremap ]t          :tabnext<cr>
nnoremap [t          :tabprevious<cr>

nnoremap <c-h>       <c-w>h
nnoremap <c-j>       <c-w>j
nnoremap <c-k>       <c-w>k
nnoremap <c-l>       <c-w>l

nnoremap <f9>        :silent! make<cr>:redraw!<cr>:cwindow<cr>

onoremap gv          :<c-u>normal! gv<cr>

xnoremap <           <gv
xnoremap >           >gv

nnoremap }           }zz
nnoremap {           {zz
nnoremap ]]          ]]zz
nnoremap [[          [[zz
nnoremap []          []zz
nnoremap ][          ][zz

nnoremap g;          g;zz
nnoremap g,          g,zz

nnoremap Q           gqap

nnoremap <leader>M   :<c-u><c-r>='let @'. v:register .' = '. string(getreg(v:register))<cr><c-f><left>
nnoremap <leader>j   <C-^>
nnoremap <leader>v   `[v`]

nnoremap <leader>q   :call <sid>exit()<cr>
nnoremap <leader>w   :update<cr>
nnoremap <leader>x   :xit<cr>

nnoremap <leader>l   :noh<cr>:diffupdate<cr>:syntax sync fromstart<cr><c-l>

nnoremap '           `
nnoremap `           '

nnoremap <expr> <cr> &ft == 'vim' && &bt == 'nofile' ? '<cr>' : 'g<c-]>'
nnoremap <bs>        <c-t>

inoremap jf          <esc>

cnoremap <leader>r   $VIMRUNTIME/

xnoremap *           :<c-u>call <sid>search()<cr>//<cr>
xnoremap #           :<c-u>call <sid>search()<cr>??<cr>
xnoremap <leader>*   :<c-u>silent! execute <sid>search_all()<cr>

" autocmd {{{1
" autocmd -> misc {{{2
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif | normal! zvzz

au BufEnter           *                           Cd
au BufLeave           *.h                         normal! mH
au BufLeave           *.{c,cpp}                   normal! mC
au BufRead,BufNewFile *.[sS]                      let b:asmsyntax = 'gas'
au BufRead,BufNewFile *.adoc                      setfiletype asciidoc
au BufRead,BufNewFile *.{md,mkd}                  setlocal ft=markdown tw=80
au BufRead,BufNewFile /data/repo/neovim/*         setlocal et sts=2 sw=2 cino=>2,l1,p0,)50,*50,t0
au BufRead,BufNewFile /data/uni/techgi2/*.{s,asm} setlocal ft=mips
au BufRead,BufNewFile Makefile.*,local.mk         setfiletype make
au BufReadPost        fugitive://                 setlocal bufhidden=delete
au BufWritePost       ~/.Xdefaults                redraw | echo system('xrdb ' . expand('<amatch>'))
au FileType           help                        silent wincmd T
au FileType           mail                        setlocal textwidth=72 wrap linebreak
au VimEnter           *                           if isdirectory(expand('<afile>')) | Ex | endif

" autocmd -> special {{{2
au BufEnter $VIMRUNTIME/doc/*
      \ if &buftype == "help" |
      \   setl scrolloff   =0 |
      \   setl statusline  =\ \[HELP\] |
      \   setl statusline +=\ \%F |
      \   setl statusline +=%=\ %P\  |
      \ endif |
      \ nnoremap <buffer> q :q!<CR>

au FileType qf
      \ nnoremap <buffer> q :q<cr>

au FileType man
      \ setl nocul nomod nolist nonu nornu |
      \ nnoremap <buffer> q :q<cr>

augroup binary
  autocmd!
  autocmd BufReadPost  * if &bin | silent! exe '%!xxd'    | setlocal filetype=xxd | endif
  autocmd BufWritePre  * if &bin | silent! exe '%!xxd -r' | endif
  autocmd BufWritePost * if &bin | silent! exe '%!xxd'    | setlocal nomodified | endif
augroup end

" commands {{{1
command! -nargs=* -bar -complete=help H        helpgrep <args>
command! -nargs=+ -bar -complete=file Ag       silent! grep! <args> | cwindow | redraw!
command! -nargs=0 -bar -bang          Cd       call s:cd(<bang>0)
command! -nargs=0 -bar Scriptnames call <sid>scratch('scriptnames') | silent g/^$/d
command! -nargs=1 -bar -complete=command Scratch call <sid>scratch(<f-args>)

" functions {{{1
function! s:cd(bang) abort
  if &buftype == 'nofile' || expand('%') =~# '^fugitive'
    return
  endif
  let s:cache = {}
  let dirs    = [ '.git', '.hg' ]
  let curdir  = resolve(expand('%:p:h'))
  if has_key(s:cache, curdir)
    execute (a:bang ? 'cd' : 'lcd') s:cache.curdir
    return
  endif
  for dir in dirs
    let founddir = finddir(dir, curdir .';')
    if !empty(founddir)
      break
    endif
  endfor
  let dir = empty(founddir) ? curdir : resolve(fnamemodify(founddir, ':p:h:h'))
  let s:cache[curdir] = dir
  execute (a:bang ? 'cd' : 'lcd') dir
endfunction

function! s:scratch(cmd) abort
  let more = &more
  set nomore
  try
    let lines = 1
    redir => lines
    silent execute a:cmd
  finally
    redir END
    let &more = more
  endtry
  noautocmd new
  setlocal buftype=nofile bufhidden=hide noswapfile
  silent put =lines
  1
  nnoremap <buffer> q :q<cr>
endfunction

function! Foldy()
  let linelen = &tw ? &tw : 80
  let marker  = strpart(&fmr, 0, stridx(&fmr, ',')) . '\d*'
  let range   = foldclosedend(v:foldstart) - foldclosed(v:foldstart) + 1

  let left    = substitute(getline(v:foldstart), marker , '', '')
  let leftlen = len(left)

  let right    = range . ' [' . v:foldlevel . ']'
  let rightlen = len(right)

  let tmp    = strpart(left, 0, linelen - rightlen)
  let tmplen = len(tmp)

  if leftlen > len(tmp)
    let left    = strpart(tmp, 0, tmplen - 4) . '... '
    let leftlen = tmplen
  endif

  let fill = repeat(' ', linelen - (leftlen + rightlen))

  return left . fill . right . repeat(' ', 100)
endfunction

function! s:exit()
  let nlisted = len(filter(range(0, bufnr('$')), 'buflisted(v:val)'))
  if nlisted < 2 || (&filetype == 'vim' && &buftype == 'nofile') " cmdline window
    quit
  else
    bd
  endif
endfunction

function! s:search() abort
  let regsave = @@
  normal! gvy
  let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
  let @@ = regsave
endfunction

function! s:search_all() abort
  call <sid>search()
  call setqflist([])
  execute 'bufdo vimgrepadd! /'. @/ .'/ %'
endfunction

" statusline {{{1
highlight User1 ctermfg=192 ctermbg=237 cterm=NONE
highlight User2 ctermfg=167 ctermbg=237 cterm=NONE
highlight User3 ctermfg=245 ctermbg=237 cterm=NONE
highlight User4 ctermfg=215 ctermbg=237 cterm=NONE

function! SetStatusline()
  let stl = ' %4*%<%F%*'

  if exists('b:git_dir')
    let stl    .= '%3*:%*'
    let branch  = fugitive#head(8)
    let stl    .= (branch == 'master') ? '%1*master%*' : '%2*'. branch .'%*'
  endif

  let stl .=
        \   '%m%r%h%w'
        \ . '%= '
        \ . '%#ErrorMsg#%{&paste ? " paste " : ""}%*'
        \ . '%#WarningMsg#%{&ff != "unix" ? " ".&ff." ":""}%* '
        \ . '%#warningmsg#%{&fenc != "utf-8" && &fenc != "" ? " ".&fenc." " :""}%* '

  if get(b:, 'debug_highlight')
      let stl .=
            \   '%#WarningMsg#['
            \ . '%{synIDattr(synIDtrans(synID(line("."),col("."),1)),"name")} '
            \ . '%{synIDattr(synID(line("."),col("."),1),"name")}'
            \ . ']%* '
  endif

  let stl .=
        \   '%Y '
        \ . '%3*[%*%v%3*,%*%l%3*/%*%L%3*]%* '
        \ . '%p%3*%%%* '

  return stl
endfunction

set statusline=%!SetStatusline()

" plugins {{{1
" plugins: misc {{{2
let g:is_bash      = 1
let g:lisp_rainbow = 1

let g:loaded_2html_plugin     = 1
let g:loaded_getscriptPlugin  = 1
"let g:loaded_gzip             = 1
let g:loaded_rrhelper         = 1
let g:loaded_spellfile_plugin = 1
"let g:loaded_tarPlugin        = 1
let g:loaded_vimballPlugin    = 1
"let g:loaded_zipPlugin        = 1

" plugins: command-t {{{2
let g:CommandTAlwaysShowDotFiles = 0
let g:CommandTScanDotDirectories = 1
let g:CommandTMatchWindowReverse = 1

nnoremap <leader>B :CommandTJump<cr>
nnoremap <leader>b :CommandTBuffer<cr>
nnoremap <leader>m :CommandTMRU<cr>
nnoremap <leader>p :CommandT<cr>
nnoremap <leader>t :CommandTTag<cr>

" plugins: netrw {{{2
" let g:loaded_netrwPlugin = 1
let g:netrw_banner       = 0
let g:netrw_keepdir      = 0
let g:netrw_liststyle    = 1
let g:netrw_sort_options = 'i'

" plugins: surround {{{2
let g:surround_indent = 1
let g:surround_{char2nr('e')} = "\\emph{\r}"
let g:surround_{char2nr('-')} = "<% \r %>"
let g:surround_{char2nr('8')} = "/* \r */"
let g:surround_{char2nr('s')} = " \r"
let g:surround_{char2nr('^')} = "/^\r$/"
let g:surround_{char2nr('=')} = "== \r =="

" plugins: syntastic {{{2
let g:syntastic_enable_signs        = 1
let g:syntastic_check_on_open       = 0
let g:syntastic_enable_highlighting = 1
let g:syntastic_auto_jump           = 0
let g:syntastic_quiet_messages      = { 'level': 'warnings' }
let g:syntastic_mode_map            = {
      \ 'mode'             : 'passive',
      \ 'active_filetypes' : [ 'c' ],
      \ 'passive_filetypes': []
      \ }

let g:syntastic_c_compiler_options   = '-std=c11 -pedantic -Wall -Wextra -Wfloat-equal -ftrapv'
let g:syntastic_cpp_compiler_options = '-std=c++11 -pedantic -Wall -Wextra -Weffc++'

" plugins: tagbar {{{2
let g:tagbar_width     = 40
let g:tagbar_autoclose = 1
let g:tagbar_autofocus = 1
let g:tagbar_compact   = 1

" plugins: vim-easymotion {{{2
let g:EasyMotion_do_mapping        = 0
let g:EasyMotion_do_shade          = 1
let g:EasyMotion_inc_highlight     = 0
let g:EasyMotion_landing_highlight = 0
let g:EasyMotion_off_screen_search = 0
let g:EasyMotion_smartcase         = 0
let g:EasyMotion_startofline       = 0
let g:EasyMotion_use_smartsign_us  = 1
let g:EasyMotion_use_upper         = 0

map <space>   <plug>(easymotion-s2)
" map <Leader>j <plug>(easymotion-j)
" map <Leader>k <plug>(easymotion-k)

" plugins: vim-signify {{{2
let g:signify_vcs_list           = [ 'git', 'hg' ]
"let g:signify_skip_filetype      = { 'help': 1 }
"let g:signify_cursorhold_insert  = 1
"let g:signify_cursorhold_normal  = 1
"let g:signify_disable_by_default = 1
" let g:signify_line_highlight     = 0
"let g:signify_update_on_bufenter = 1
" let g:signify_update_on_focusgained = 0

function! RunOnModifiedLines(lnums) abort
  for lnum in a:lnums
    execute 'silent! '. lnum .'substitute/\s\+$//'
  endfor
endfunction

"let g:signify_action_on_modified_lines = 'RunOnModifiedLines'

" plugins: vim-startify {{{2
"autocmd FileType startify setlocal cursorline
"autocmd User Startified call lightline#update()

let g:startify_list_order = [
      \ ['   LRU:'],
      \ 'files',
      \ ['   LRU within this dir:'],
      \ 'dir',
      \ ['   Sessions:'],
      \ 'sessions',
      \ ['   Bookmarks:'],
      \ 'bookmarks',
      \ ]

"let g:startify_session_savevars = ['g:foo']
"let g:startify_session_savecmds = [ 'colo molokai' ]

let g:startify_relative_path          = 1
let g:startify_files_number           = 10
let g:startify_session_persistence    = 1
let g:startify_session_autoload       = 1
let g:startify_session_delete_buffers = 1
let g:startify_change_to_dir          = 1
let g:startify_enable_special         = 0
"let g:startify_restore_position = 1
"let g:startify_custom_indices = map(range(1,100), 'string(v:val)')
"let g:startify_list_order = ['files', 'bookmarks', 'sessions', 'dir']

let g:startify_skiplist = [
      \ 'COMMIT_EDITMSG',
      \ $VIMRUNTIME .'/doc',
      \ 'bundle/.*/doc',
      \ '\.vimgolf',
      \ ]

"let g:startify_bookmarks = [ expand('<sfile>:p:~') ]
"let g:startify_bookmarks = [
            "\ '~/.vim/vimrc',
            "\ '/data/vim/golfing',
            "\ ]

"let g:startify_custom_footer = ['', "   Vim is charityware. Please read ':help uganda'.", '']
let g:startify_custom_header = map(split(system('tips | cowsay -f apt'), '\n'), '"   ". v:val') + ['']
"function! s:foo()
    "redir => var
      "silent! echomsg 'foo'
      "silent! echomsg 'bar'
      "silent! echomsg 'quux'
    "redir END
    "return map(split(var, '\n'), '"   " . v:val') + ['']
"endfunction
"let g:startify_custom_header = s:foo()

" plugins: vim-tmuxify {{{2
let g:tmuxify_custom_command = 'tmux split-window -d -l 10'
let g:tmuxify_run = {
      \ 'sh':   'bash %',
      \ 'go':   'go build %',
      \ 'ruby': 'ruby %',
      \ }
