" vim: et sts=2 sw=2
"
"
"   You are about to experience a potent dosage of Vim. Watch your steps.
"
"                ╔══════════════════════════════════════════╗
"                ║           ⎋ HERE BE VIMPIRES ⎋           ║
"                ╚══════════════════════════════════════════╝
"

" plug {{{1
call plug#begin('~/.vim/bundle')
  " Plug 'Harenome/vim-mipssyntax', { 'for': ['s', 'asm'] }
  " Plug 'Lokaltog/vim-distinguished'
  " Plug 'Shirk/vim-gas'
  " Plug 'davidhalter/jedi-vim',    { 'for': 'python'     }
  " Plug 'jimenezrick/vimerl',      { 'for': 'erlang'     }
  " Plug 'junegunn/goyo.vim',       { 'on': 'Goyo'                         }
  " Plug 'mattn/gist-vim',
  " Plug 'terryma/vim-multiple-cursors'
  " Plug 'tpope/vim-scriptease'
  " Plug 'vim-scripts/armasm'
  " Plug 'vim-scripts/rfc-syntax'

  Plug 'scrooloose/syntastic'

  Plug 'Lokaltog/vim-easymotion'
  Plug 'chrisbra/vim_faq'
  Plug 'dahu/LearnVim'
  Plug 'jamessan/vim-gnupg'
  Plug 'junegunn/limelight.vim',  { 'on': 'Limelight'                    }
  Plug 'majutsushi/tagbar',       { 'on': 'TagbarToggle'                 }
  Plug 'msanders/snipmate.vim',   { 'frozen': 1                          }
  Plug 'scrooloose/nerdtree',     { 'on': ['NERDTree', 'NERDTreeToggle'] }
  Plug 'tpope/vim-commentary'
  Plug 'tpope/vim-dispatch'
  Plug 'tpope/vim-endwise'
  Plug 'tpope/vim-fugitive'
  Plug 'tpope/vim-rsi'
  Plug 'tpope/vim-surround'
  Plug 'wincent/command-t'

  Plug '/data/github/vim-janah'
  Plug '/data/github/vim-randomtag', { 'on': 'Random' }
  Plug '/data/github/vim-signify'
  Plug '/data/github/vim-startify'
  Plug '/data/github/vim-tmuxify'
call plug#end()

" init {{{1
"filetype plugin indent on
"syntax   on

"autocmd BufReadPre *.asm let b:asmsyntax = 'nasm'
"let b:asmsyntax = 'armasm'
let b:debug_highlight = 0

if &term =~# '^rxvt|\xterm'
  let &t_SI = "\<Esc>]12;1\x7"
  let &t_EI = "\<Esc>]12;3\x7"
endif

" colors {{{1
if has('gui_running')
  set background=light
  for scheme in ['zenburn', 'pyte', 'solarized']
    try
      execute 'colorscheme' scheme
      break
    catch
    endtry
  endfor
  set gcr        =a:blinkoff0
  set mousehide
  set guioptions =a
  let &guifont   = 'DejaVu Sans Mono 9'
else
  set background=dark
  for scheme in ['janah', 'zenburn', 'xoria256', 'tango2']
    try
      execute 'colorscheme' scheme
      break
    catch
    endtry
  endfor
  if colors_name == 'janah'
    highlight Normal ctermbg=NONE
  endif
endif

" set {{{1

" indent settings
set autoindent
set cinoptions    =>4,l1,p0,)50,*50,t0
set expandtab
set shiftwidth    =4
set softtabstop   =4

" backup/swap/info/undo settings
set backup
set backupdir     =$HOME/.vim/files/backup/
set backupext     =-vimbackup
set backupskip    =
set directory     =$HOME/.vim/files/swap//
set undodir       =$HOME/.vim/files/undo/
set undofile
set updatecount   =100
set viminfo       ='100,n$HOME/.vim/files/info/viminfo

" better navigation
set cursorline
set foldmethod    =marker
set foldtext      =Foldy()
set hlsearch
set ignorecase
set incsearch
set mouse         =a
set scrolloff     =4
set sidescroll    =5
set smartcase

" misc settings
set autoread
set backspace     =indent,eol,start
set cpoptions    -=e
set cscopetag
set cscopetagorder=0
set diffopt       =filler,foldcolumn:0
set fileformats   =unix,dos,mac
set hidden
set history       =10000
set lazyredraw
set more
set mousemodel    =popup
set noautoread
set noautowrite
set noautowriteall
set noequalalways
set noerrorbells
set nofsync
set nojoinspaces
set nrformats     =hex
set pastetoggle   =<F5>
set report        =0
set shiftround
set showfulltag
set showtabline   =1
set smarttab
set splitbelow
set splitright
set switchbuf     =useopen,usetab
set synmaxcol     =200
set timeout
set timeoutlen    =1000
set titlestring   =VIM:\ %f
set ttimeout
set ttimeoutlen   =10
set ttyfast
set virtualedit   =onemore,block
set whichwrap     =

" wild stuff
set suffixes     +=.a,.1,.class
set wildignore   +=*.o,*.so,*.zip,*.png
set wildmenu
set wildmode      =list,full

" display settings
set laststatus    =2
set list
set modeline
set modelines     =1
set nostartofline
set numberwidth   =1
set ruler
set shortmess     =aoOTI
set showcmd
set showmatch
set showmode

" breaking
set wrap
set linebreak
set breakindent
set breakindentopt=min:40
"set highlight    +=@:SpecialKey
"set cpoptions    +=n

if has('multi_byte') && &encoding ==# 'utf-8'
  let &listchars = 'tab:▸ ,extends:❯,precedes:❮,nbsp:±'
  let &fillchars = 'vert:\u259a,diff:28ff,stlnc:!'
  let &showbreak = '↪ '
  highlight VertSplit ctermfg=242
  autocmd InsertEnter * set listchars-=trail:·
  autocmd InsertLeave * set listchars+=trail:·
else
  let &listchars = 'tab:> ,extends:>,precedes:<,nbsp:.'
  let &fillchars = 'stlnc:#'
  let &showbreak = '-> '
  autocmd InsertEnter * set listchars-=trail:.
  autocmd InsertLeave * set listchars+=trail:.
endif

if executable('ag')
  let &grepprg = 'command ag --nogroup --nocolor'
endif

" mapping {{{1
digraph ./ 8230

let mapleader = ';'

nnoremap K :grep! "\b<c-r><c-w>\b"<cr>:cwindow<cr>

vnoremap ;rv c<c-o>:set revins<cr><c-r>"<Esc>:set norevins<cr>

onoremap gv :<c-u>normal! gv<cr>

cnoremap <c-p> <up>
cnoremap <c-n> <down>

nnoremap <silent><leader>ev :tabnew ~/.vim/vimrc<cr>
nnoremap <silent><leader>rr :source %<cr>
nnoremap <silent><leader>rv :source $MYVIMRC<cr:

nnoremap <expr> n v:searchforward ? 'nzvzz' : 'Nzvzz'
nnoremap <expr> N v:searchforward ? 'Nzvzz' : 'nzvzz'

nnoremap <leader>f  zazz
nnoremap gg       ggzvzz
nnoremap G        Gzvzz

nnoremap <silent> ]q :cnext<cr>
nnoremap <silent> [q :cprevious<cr>

nnoremap <silent> ]l :lnext<cr>
nnoremap <silent> [l :lprevious<cr>

nnoremap <silent> ]b :bnext<cr>
nnoremap <silent> [b :bprevious<cr>

noremap <silent><f1> :TagbarToggle<cr>
noremap <silent><f2> :call ToggleNumbers()<cr>
noremap <silent><f4> :NERDTreeToggle<cr>
noremap <silent><f6> :call CreateTags()<cr>
nnoremap <silent><f9> :silent! make<cr>:redraw!<cr>:cwindow<cr>

nnoremap <leader>gv `[v`]

xnoremap < <gv
xnoremap > >gv

nnoremap }  }zz
nnoremap {  {zz
nnoremap ]] ]]zz
nnoremap [[ [[zz
nnoremap [] []zz
nnoremap ][ ][zz

nnoremap & :&&<cr>
vnoremap & :&&<cr>

nnoremap Q gqap
nnoremap g; g;zz

nnoremap <leader>s   :SyDebug \| sign place buffer=1<cr>
nnoremap <leader>M   :<c-u><c-r>='let @'. v:register .' = '. string(getreg(v:register))<cr><c-f><left>

noremap <down>       <c-w>+
noremap <up>         <c-w>-
"noremap <Left>       <C-w>>
"noremap <Right>      <C-w><
noremap <c-n>        :tabn<cr>
noremap <c-p>        :tabp<cr>
"noremap <C-i>        gk

nnoremap <tab>       %
nnoremap ,f          :tabedit %<CR>
nnoremap ,d          :tabclose<CR>
nnoremap ,c          :cclose<CR>
nnoremap <leader>co  :botright copen 5<CR><C-w>p
nnoremap <leader>cn  :cnext<CR>
nnoremap -           :cnext<CR>
nnoremap <right>     :cnext<CR>
nnoremap <leader>cp  :cprevious<CR>
nnoremap <left>      :cprevious<CR>
nnoremap <leader>ce  :clast<CR>

nnoremap <leader>aa  :call ToggleCommentColor()<CR>

function! s:SOL()
  let cursorpos = col('.')
  normal! 0
  if searchpos('\S', 'ne')[1] != cursorpos
    normal! ^
  endif
endfunction
nnoremap <silent><c-h> :call <sid>SOL()<cr>

nnoremap <leader>v   `[v`]
nnoremap <leader>j   <C-^>
nnoremap <silent> <leader>n   :bn<cr>
nnoremap <silent> <leader>p   :bp<cr>
nnoremap <silent> <leader>q   :call <sid>exit()<cr>
nnoremap <silent> <leader>w   :up<cr>
nnoremap <leader>x   :x<cr>
nnoremap <silent><leader>l :noh<cr>:diffupdate<cr>:syntax sync fromstart<cr><c-l>
nnoremap <bs>        <c-t>
nnoremap <c-j>       <c-w>j
nnoremap <c-k>       <c-w>k
nnoremap <c-l>       <c-w>l
nnoremap <expr>      <cr> &ft == 'vim' && &bt == 'nofile' ? '<cr>' : 'g<c-]>'
nnoremap <f10>       :call <sid>ToggleTooLongHL()<cr>
"nnoremap <silent>F   :pu=''<CR>
nnoremap '           `
nnoremap `           '

inoremap <c-f>       <c-x><c-o>
inoremap <c-b>       <c-x><c-u>
inoremap jf          <esc>

vmap <space>         <leader>c<space>
vnoremap Y           "+y

cnoremap <c-b>       <left>
cnoremap <c-f>       <right>
cnoremap <c-a>       <home>
cnoremap <c-e>       <end>

cnoremap <leader>r   $VIMRUNTIME/

" autocmd {{{1
" autocmd -> misc {{{2
"au BufRead,BufNewFile       *                silent! call mkdir(expand('<afile>:p:h'), 'p', 0700) | e <afile>
"au BufEnter                 *                if &ft != 'help' | silent! cd %:p:h | endif
au BufEnter           *                           Cd
au BufLeave           *.h                         normal! mH
au BufLeave           *.{c,cpp}                   normal! mC
au BufRead,BufNewFile *.[sS]                      let b:asmsyntax = 'gas'
au BufRead,BufNewFile *.adoc                      setfiletype asciidoc
au BufRead,BufNewFile *.{md,mkd}                  setlocal ft=markdown tw=80
au BufRead,BufNewFile /data/repo/neovim/*         setlocal et sts=2 sw=2 cino=>2,l1,p0,)50,*50,t0
au BufRead,BufNewFile /data/repo/vim/*            setlocal tags+=/data/repo/vim/.hg/tags
au BufRead,BufNewFile /data/uni/mpgi2/*.java      setlocal et sts=2 sw=2
au BufRead,BufNewFile /data/uni/techgi2/*.{s,asm} setlocal ft=mips
au BufRead,BufNewFile /etc/nginx/*                setfiletype nginx
au BufRead,BufNewFile Makefile.*,local.mk         setfiletype make
au BufRead,BufNewFile ~/.dotfiles/ssh/config      setfiletype sshconfig
au BufReadPost        *                           LastPos | normal! zvzz
au BufReadPost        fugitive://                 setlocal bufhidden=delete
au BufWritePost       ~/.Xdefaults                redraw | echo system('xrdb ' . expand('<amatch>'))
au FileType           help                        silent wincmd T
au FileType           text                        if expand('%:t') =~? '\(rfc\|std\)\d\+.txt' | setl ft=rfc | endif
au VimEnter           *                           if isdirectory(expand('<afile>')) | quit | endif
"au VimEnter                *                if isdirectory(expand('<afile>')) | Ex | endif
"autocmd VimEnter * if !argc() | Startify | NERDTree | execute "normal \<c-w>w" | endif

" autocmd -> special {{{2
au BufEnter $VIMRUNTIME/doc/*
      \ if &buftype == "help" |
      \   setl scrolloff   =0 |
      \   setl statusline  =\ \[HELP\] |
      \   setl statusline +=\ \%F |
      \   setl statusline +=%=\ %P\  |
      \ endif |
      \ nnoremap <buffer> q :q!<CR>

au FileType qf
      \ nnoremap <buffer> q :q<cr>

au FileType man
      \ setl nocul nomod nolist nonu nornu |
      \ nnoremap <buffer> q :q<cr>

aug mail
  autocmd!
  autocmd FileType mail setl tw=70 wrap lbr
aug end

aug binary
  autocmd!
  autocmd BufReadPost  * if &bin | silent! exe '%!xxd'    | set ft=xxd | endif
  autocmd BufWritePre  * if &bin | silent! exe '%!xxd -r' | endif
  autocmd BufWritePost * if &bin | silent! exe '%!xxd'    | set nomod | endif
augroup end

" commands {{{1
command! -bar -nargs=* -complete=help H        helpgrep <args>
command! -bar -nargs=+ -complete=file Ag       silent! grep! <args> | cwindow | redraw!
command! -bar -nargs=0                Helptags helptags $VIMRUNTIME/doc
command! -bar -nargs=0                Kill     bprevious | split | bnext | bdelete
command! -bar -nargs=0                LastPos  if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
command! -bar -nargs=0 -bang          Cd       call s:cd(<bang>0)

" functions {{{1
function! s:cd(bang)
  if &buftype == 'nofile'
    return
  endif
  let s:cache = {}
  let dirs    = [ '.git', '.hg' ]
  let curdir  = resolve(expand('%:p:h'))
  if has_key(s:cache, curdir)
    execute (a:bang ? 'cd' : 'lcd') s:cache.curdir
    return
  endif
  for dir in dirs
    let founddir = finddir(dir, curdir .';')
    if !empty(founddir)
      break
    endif
  endfor
  let dir = empty(founddir) ? curdir : resolve(fnamemodify(founddir, ':p:h:h'))
  let s:cache[curdir] = dir
  execute (a:bang ? 'cd' : 'lcd') dir
endfunction

function! s:vfun() abort
  if !exists('s:vfun')
    let id     = synIDtrans(hlID('VertSplit'))
    let s:vfun = {
          \ 'fg' : synIDattr(id, 'fg'),
          \ 'bg' : synIDattr(id, 'bg'),
          \ 'fcs': &fillchars }
    highlight VertSplit ctermfg=198 ctermbg=155
    let &fcs = "vert:\u259a"
    "let &fcs = "vert:\u28ff"
  else
    execute 'highlight VertSplit ctermfg='. s:vfun.fg 'ctermbg='. s:vfun.bg
    let &fcs = s:vfun.fcs
    unlet s:vfun
  endif
endfunction

command! -nargs=0 -bar VFun call s:vfun()

function! s:scratch(cmd) abort
  let more = &more
  set nomore
  try
    let lines = 1
    redir => lines
    silent execute a:cmd
  finally
    redir END
    let &more = more
  endtry
  noautocmd new
  setlocal buftype=nofile bufhidden=hide noswapfile
  silent put =lines
  1
  nnoremap <buffer> q :q<cr>
endfunction

command! -nargs=0 -bar Scriptnames call <sid>scratch('scriptnames') | silent g/^$/d
command! -nargs=1 -bar -complete=command Scratch call <sid>scratch(<f-args>)

function! s:try(cmd, default) abort
  if exists(':' . a:cmd) && !v:count
    let tick = b:changedtick
    execute a:cmd
    if b:changedtick == tick
      execute 'normal!' a:default
    endif
  else
    execute 'normal!' v:count.a:default
  endif
endfunction

nnoremap <silent> J :<c-u>call <sid>try('SplitjoinJoin', 'J')<cr>

function! s:count_characters(bang) range abort
  let nchars = 0
  let lines  = a:bang ? range(1, line('$')) : range(a:firstline, a:lastline)

  for line in lines
    let nchars += strlen(getline(line))
  endfor

  if a:bang
    echomsg '>>> The file contains '. nchars .' characters.'
  else
    echomsg '>>> Lines '. a:firstline .' to '. a:lastline .' contain '. nchars .' characters.'
  endif
endfunction

command! -range -bang -bar Count <line1>,<line2>call s:count_characters(<bang>0)

function! Foldy()
  let linelen = &tw ? &tw : 80
  let marker  = strpart(&fmr, 0, stridx(&fmr, ',')) . '\d*'
  let range   = foldclosedend(v:foldstart) - foldclosed(v:foldstart) + 1

  let left    = substitute(getline(v:foldstart), marker , '', '')
  let leftlen = len(left)

  let right    = range . ' [' . v:foldlevel . ']'
  let rightlen = len(right)

  let tmp    = strpart(left, 0, linelen - rightlen)
  let tmplen = len(tmp)

  if leftlen > len(tmp)
    let left    = strpart(tmp, 0, tmplen - 4) . '... '
    let leftlen = tmplen
  endif

  let fill = repeat(' ', linelen - (leftlen + rightlen))

  return left . fill . right . repeat(' ', 100)
endfunction

function! s:exit()
  let nlisted = len(filter(range(0, bufnr('$')), 'buflisted(v:val)'))
  if nlisted < 2 || (&filetype == 'vim' && &buftype == 'nofile') " cmdline window
    quit
  else
    bd
  endif
endfunction

function! Tags()
  if executable('ctags')
    silent! !ctags -R
  else
    echoerr 'No ctags installed!'
  endif
  if has('cscope') && executable('cscope')
    silent! !cscope -Rbq
    redraw!
  else
    echoerr 'No cscope installed!'
  endif
endfunction

function! ToggleScratchpad(cmd)
  let cmd = (a:cmd) ? ('e ' . expand('%:p') . '.scratch') : 'e ~/.scratchpad'

  if !exists('t:scratch_toggle')
    let t:scratch_toggle = 1
    let scratch_height   = &previewheight
    let &previewheight   = 5
    exe 'above pedit +' . cmd
    if &readonly == 1 || &modifiable == 0
      wincmd p
      set noreadonly
      set modifiable
      wincmd p
    endif
    let &previewheight = scratch_height
  else
    unlet t:scratch_toggle
    pclose
  endif
endfunction

function! s:open_url(url)
  if has('win32')
    exe "!start cmd /cstart /b " . a:url . ""
  elseif $DISPLAY !~ '^w'
    exe "silent !firefox \"" . a:url . "\""
  else
    exe "silent !firefox -new-tab \"" . a:url . "\""
  endif
  redraw!
endfunction
command! -nargs=1 URL :call s:open_url(<q-args>)
nnoremap gL :URL <cfile><cr>
nnoremap gD :URL http://www.dict.cc/?s=<cword><cr>
nnoremap gG :URL http://www.google.com/search?q=<cword><cr>
nnoremap gW :URL http://en.wikipedia.org/wiki/Special:Search?search=<cword><cr>

function! ToggleNumbers()
  if !exists('s:curnum')
    let s:curnum = 0
  endif
  if s:curnum == 0
    set nonu rnu
  elseif s:curnum == 1
    set nu nornu
  else
    set nonu nornu
  endif
  let s:curnum = (s:curnum + 1) % 3
endfunction

function! ToggleCommentColor()
  if !exists("g:ToggleCommentColor")
    hi comment ctermfg=83 cterm=none
    let g:ToggleCommentColor = 1
  else
    hi comment ctermfg=240 cterm=none
    unlet g:ToggleCommentColor
  endif
endfunction

function! CreateTags()
  let b:choice = input("(s)ingle or whole (f)older? ", "s")
  if (b:choice == 's')
    silent! !ctags %
    redraw!
    echo "tags file created (single)"
  elseif (b:choice == 'f')
    silent! !ctags -R .
    redraw!
    echo "tags file created (folder)"
  else
    echo "Wrong input."
  endif
endfunction

function! <sid>ToggleTooLongHL()
  if exists('*matchadd')
    if ! exists("w:TooLongMatchNr")
      let last = (&tw <= 0 ? 80 : &tw)
      let w:TooLongMatchNr = matchadd('ErrorMsg', '.\%>' . (last+1) . 'v', 0)
      echo "Long Line Highlight"
    else
      call matchdelete(w:TooLongMatchNr)
      unlet w:TooLongMatchNr
      echo "No Long Line Highlight"
    endif
  endif
endfunction

function! FileSize()
  let bytes = getfsize(expand('%:p'))
  if bytes <= 0
    return
  elseif bytes < 1024
    return bytes
  endif
  return (bytes / 1024) . "k"
endfunction

function! EatChar(pat)
  let c = nr2char(getchar(0))
  return (c =~ a:pat) ? '' : c
endfunction

xnoremap * :<c-u>call PowerSearch()<cr>//<cr>
xnoremap # :<c-u>call PowerSearch()<cr>??<cr>

function! PowerSearch() abort
  let regsave = @@
  normal! gvy
  let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
  let @@ = regsave
endfunction

xnoremap <silent><leader>* :<c-u>silent! execute PowerSearchAll()<cr>

function! PowerSearchAll() abort
  call PowerSearch()
  call setqflist([])
  execute 'bufdo vimgrepadd! /'. @/ .'/ %'
endfunction

" abbreviations {{{1
iabbr _d  <c-r>=strftime("%a, %d %b %Y %H:%M:%S %z")<cr><c-r>=EatChar('\s')<cr>

" statusline {{{1
highlight User1 ctermfg=192 ctermbg=237 cterm=NONE
highlight User2 ctermfg=167 ctermbg=237 cterm=NONE
highlight User3 ctermfg=245 ctermbg=237 cterm=NONE
highlight User4 ctermfg=215 ctermbg=237 cterm=NONE

function! SetStatusline()
  let stl = ' %4*%<%F%*'

  if exists('b:git_dir')
    let stl    .= '%3*:%*'
    let branch  = fugitive#head()
    let stl    .= (branch == 'master') ? '%1*master%*' : '%2*'. branch .'%*'
  endif

  let stl .=
        \   '%m%r%h%w'
        \ . '%= '
        \ . '%#ErrorMsg#%{&paste ? " paste " : ""}%*'
        \ . '%#WarningMsg#%{&ff != "unix" ? " ".&ff." ":""}%* '
        \ . '%#warningmsg#%{&fenc != "utf-8" && &fenc != "" ? " ".&fenc." " :""}%* '

  if get(b:, 'debug_highlight')
      let stl .=
            \   '%#WarningMsg#['
            \ . '%{synIDattr(synIDtrans(synID(line("."),col("."),1)),"name")} '
            \ . '%{synIDattr(synID(line("."),col("."),1),"name")}'
            \ . ']%* '
  endif

  let stl .=
        \   '%Y '
        \ . '%3*[%*%v%3*,%*%l%3*/%*%L%3*]%* '
        \ . '%p%3*%%%* '

  return stl
endfunction

set statusline=%!SetStatusline()

" neovim {{{1
if has('nvim')
  runtime! plugin/python_setup.vim
endif

" plugins {{{1
" plugins: misc {{{2
let g:is_bash      = 1
let g:lisp_rainbow = 1

let g:loaded_2html_plugin     = 1
let g:loaded_getscriptPlugin  = 1
"let g:loaded_gzip             = 1
let g:loaded_rrhelper         = 1
let g:loaded_spellfile_plugin = 1
"let g:loaded_tarPlugin        = 1
let g:loaded_vimballPlugin    = 1
"let g:loaded_zipPlugin        = 1

" plugins: command-t {{{2
let g:CommandTAlwaysShowDotFiles = 0
let g:CommandTScanDotDirectories = 1
let g:CommandTMatchWindowReverse = 1

nnoremap <leader>B :CommandTJump<cr>
nnoremap <leader>b :CommandTBuffer<cr>
nnoremap <leader>m :CommandTMRU<cr>
nnoremap <leader>p :CommandT<cr>
nnoremap <leader>t :CommandTTag<cr>

" plugins: nerdtree {{{2
let NERDTreeDirArrows   = 1
let NERDTreeHijackNetrw = 0
let NERDTreeMinimalUI   = 1

" plugins: netrw {{{2
let g:loaded_netrwPlugin = 1
let g:netrw_banner       = 0
let g:netrw_keepdir      = 0
let g:netrw_liststyle    = 1
let g:netrw_sort_options = 'i'

" plugins: surround {{{2
let g:surround_indent = 1
let g:surround_{char2nr('e')} = "\\emph{\r}"
let g:surround_{char2nr('-')} = "<% \r %>"
"let g:surround_{char2nr('=')} = "<%= \r %>"
let g:surround_{char2nr('8')} = "/* \r */"
let g:surround_{char2nr('s')} = " \r"
let g:surround_{char2nr('^')} = "/^\r$/"
let g:surround_{char2nr('=')} = "== \r =="

" plugins: syntastic {{{2
"let g:loaded_syntastic_plugin       = 1

let g:syntastic_enable_signs        = 1
let g:syntastic_check_on_open       = 0
let g:syntastic_enable_highlighting = 1
let g:syntastic_auto_jump           = 0
let g:syntastic_quiet_messages      = { 'level': 'warnings' }
let g:syntastic_mode_map            = {
      \ 'mode'             : 'passive',
      \ 'active_filetypes' : [ 'c' ],
      \ 'passive_filetypes': []
      \ }

let g:syntastic_c_compiler_options   = '-std=c11 -pedantic -Wall -Wextra -Wfloat-equal -ftrapv'
let g:syntastic_cpp_compiler_options = '-std=c++11 -pedantic -Wall -Wextra -Weffc++'

" plugins: tagbar {{{2
let g:tagbar_width     = 40
let g:tagbar_autoclose = 1
let g:tagbar_autofocus = 1
let g:tagbar_compact   = 1

" plugins: vim-dispatch {{{2
nnoremap <leader>d  :Dispatch<cr>

" plugins: vim-easymotion {{{2
let g:EasyMotion_do_mapping        = 0
let g:EasyMotion_do_shade          = 1
let g:EasyMotion_inc_highlight     = 0
let g:EasyMotion_landing_highlight = 0
let g:EasyMotion_off_screen_search = 0
let g:EasyMotion_smartcase         = 0
let g:EasyMotion_startofline       = 0
let g:EasyMotion_use_smartsign_us  = 1
let g:EasyMotion_use_upper         = 0

map <space>   <plug>(easymotion-s2)
map <Leader>j <plug>(easymotion-j)
map <Leader>k <plug>(easymotion-k)

" plugins: vim-fugitive {{{2
nnoremap <leader>ga  :Gadd<cr>
nnoremap <leader>gb  :Gblame<cr>
nnoremap <leader>gci :Gcommit<cr>
nnoremap <leader>gco :Gcheckout<cr>
nnoremap <leader>gd  :Gdiff<cr>
nnoremap <leader>gm  :Gmove<cr>
nnoremap <leader>gr  :Gremove<cr>
nnoremap <leader>gs  :Gstatus<cr>
nnoremap <leader>gw  :Gwrite<cr>

" plugins: vim-signify {{{2
"let g:loaded_signify = 1

let g:signify_vcs_list           = [ 'git', 'hg' ]
"let g:signify_skip_filetype      = { 'help': 1 }
"let g:signify_cursorhold_insert  = 1
"let g:signify_cursorhold_normal  = 1
"let g:signify_disable_by_default = 1
"let g:signify_line_highlight     = 1
"let g:signify_sign_overwrite     = 1
"let g:signify_update_on_bufenter = 1

function! RunOnModifiedLines(lnums) abort
  for lnum in a:lnums
    execute 'silent! '. lnum .'substitute/\s\+$//'
  endfor
endfunction

"let g:signify_action_on_modified_lines = 'RunOnModifiedLines'

" plugins: vim-startify {{{2
"let g:loaded_startify = 1

"autocmd FileType startify setlocal cursorline
"autocmd User Startified call lightline#update()

let g:startify_list_order = [
      \ ['   LRU:'],
      \ 'files',
      \ ['   LRU within this dir:'],
      \ 'dir',
      \ ['   Sessions:'],
      \ 'sessions',
      \ ['   Bookmarks:'],
      \ 'bookmarks',
      \ ]

"let g:startify_session_savevars = ['g:foo']
"let g:startify_session_savecmds = [ 'colo molokai' ]

let g:startify_relative_path          = 1
let g:startify_files_number           = 10
let g:startify_session_persistence    = 1
let g:startify_session_autoload       = 1
let g:startify_session_delete_buffers = 1
let g:startify_change_to_dir          = 1
let g:startify_enable_special         = 0
"let g:startify_restore_position = 1
"let g:startify_custom_indices = map(range(1,100), 'string(v:val)')
"let g:startify_list_order = ['files', 'bookmarks', 'sessions', 'dir']

let g:startify_skiplist = [
      \ 'COMMIT_EDITMSG',
      \ $VIMRUNTIME .'/doc',
      \ 'bundle/.*/doc',
      \ '\.vimgolf',
      \ ]

"let g:startify_bookmarks = [ expand('<sfile>:p:~') ]
"let g:startify_bookmarks = [
            "\ '~/.vim/vimrc',
            "\ '/data/vim/golfing',
            "\ ]

"let g:startify_custom_footer = ['', "   Vim is charityware. Please read ':help uganda'.", '']
let g:startify_custom_header = map(split(system('tips | cowsay -f apt'), '\n'), '"   ". v:val') + ['']
"function! s:foo()
    "redir => var
      "silent! echomsg 'foo'
      "silent! echomsg 'bar'
      "silent! echomsg 'quux'
    "redir END
    "return map(split(var, '\n'), '"   " . v:val') + ['']
"endfunction
"let g:startify_custom_header = s:foo()

"let g:startify_custom_header = [
            "\ '                                 ________  __ __        ',
            "\ '            __                  /\_____  \/\ \\ \       ',
            "\ '    __  __ /\_\    ___ ___      \/___//''/''\ \ \\ \    ',
            "\ '   /\ \/\ \\/\ \ /'' __` __`\        /'' /''  \ \ \\ \_ ',
            "\ '   \ \ \_/ |\ \ \/\ \/\ \/\ \      /'' /''__  \ \__ ,__\',
            "\ '    \ \___/  \ \_\ \_\ \_\ \_\    /\_/ /\_\  \/_/\_\_/  ',
            "\ '     \/__/    \/_/\/_/\/_/\/_/    \//  \/_/     \/_/    ',
            "\ '',
            "\ '',
            "\ ]

" plugins: vim-tmuxify {{{2
let g:tmuxify_custom_command = 'tmux split-window -d -l 10'
let g:tmuxify_run = {
      \ 'sh':   'bash %',
      \ 'go':   'go build %',
      \ 'ruby': 'ruby %',
      \ }
